#! /bin/sh

cmd="$1"
test -z "$cmd" || shift

taskdir="$HOME/.tsk"
test -z "$TSK_DIR" || taskdir="$TSK_DIR"

task_template='```
title: 
tags: 
due: 
```
---
'

helpmsg() {
	name=$(basename $0)
	echo "
$name ls [query] [exclude_tags_regex]
    lists tasks and grep them up, eventually ecluding some tags
$name l [query]
    lists tasks and grep them up, excluding task with the 'done' tag
$name show | s task_id
    shows a task
$name add | a
    adds a new task
$name edit | e task_id
    open EDITOR to edit a task, even if it not exists
$name rm | r task_id
    removes a task
$name mv | m task_id to_task_id
    moves a task to another id, shifting ids of other tasks
$name compact | gc
    recompact task ids, removing holes
$name sync | y
    syncs: commit changes and pull/push with git
$name git | g [git_args]
    runs 'git git_args' in the task directory
$name clean
    purge your tasks, use with caution

Options:

    TSK_DIR  - set this env var to change tsk storage directory
"
}

errmsg() {
	local msg="$1"
	echo "ERROR: $msg" >&2
}

logd() {
	local msg="$1"
	test -z "$TSK_DEBUG" || echo "DEBUG - $msg" >&2
}

is_task_list_empty() {
	cd $taskdir
	ls -1 *.md >/dev/null 2>&1
	RET=$?
	cd - >/dev/null 2>&1
	test ! $RET = 0
}

get_task_file_list() {
	is_task_list_empty && return
	logd "taskdir: [$taskdir]"
	cd $taskdir
	file_list=$(ls -1 *.md | sort -rh)
	logd "file list: [$file_list]"
	echo -n "$file_list"
	cd - >/dev/null 2>&1
}

get_task_id_list() {
	local file_list=$(get_task_file_list)
	logd "file list for id list: [$file_list]"
	echo -n "$file_list" | sed 's/\.md$//g' | sort -rn
}

get_task_id_from_filename() {
	local filename="$1"
	basename "$filename" | sed 's/\.md$//'
}

get_task_field() {
	local task_id="$1"
	local field_name="$2"
	cat $taskdir/$task_id.md | grep "^$field_name:" | sed "s/^$field_name://"
}

list_tasks() {
	local query="$1"
	local exclude_tags_regex="$2"

	id_list=$(get_task_id_list)
	logd "id list: [$id_list]"
	for task_id in $id_list; do
		title=$(get_task_field $task_id 'title')
		tags=$(get_task_field $task_id 'tags')
		task_filepath="$taskdir/$task_id.md"
		if test ! -z "$query"; then
			cat "$task_filepath" |
				grep -i "$query" >/dev/null 2>&1 || continue
		fi
		if test ! -z "$exclude_tags_regex"; then
			echo -n "$tags" |
				grep -i "$exclude_tags_regex" >/dev/null 2>&1 &&
				continue
		fi
		tags=$(for tag in $tags; do echo -n "[$tag] "; done)
		local taskline="$title - $tags"
		if echo -n "$task_id" | grep '^[0-9]$' >/dev/null 2>&1; then
			echo "$task_id:  $taskline" # <-- extra space for alignment
		else
			echo "$task_id: $taskline"
		fi
	done
}

is_there_a_task_with_id() {
	local task_id_to_check="$1"
	for task_id in $(get_task_id_list); do
		if [ "$task_id" = "$task_id_to_check" ]; then
			return 0
		fi
	done
	return 1
}

get_first_free_id() {
	counter=1
	while true; do
		if ! is_there_a_task_with_id $counter; then
			echo $counter
			return
		fi
		counter=$(expr $counter + 1)
	done
}

get_new_id() {
	task_file_list=$(get_task_file_list)
	if test -z "$task_file_list"; then
		echo 1
	else
		get_first_free_id
	fi
}

get_next_id() {
	task_file_list=$(get_task_file_list)
	if test -z "$task_file_list"; then
		echo 1
	else
		last_id=$(echo "$task_file_list" | head -n1 | sed 's/\.md//')
		logd "last_id: $last_id"
		expr $last_id + 1
	fi
}

compact_ids() {
	id_list=$(get_task_id_list | sort -n)
	counter=1
	cd $taskdir
	for id_ in $id_list; do
		if [ $id_ -ne $counter ]; then
			mv $id_.md $counter.md
		fi
		counter=$(expr $counter + 1)
	done
	cd - >/dev/null 2>&1
}

add_task() {
	# newid=`get_new_id`
	newid=$(get_next_id)
	newfile=$taskdir/$newid.md
	echo "$task_template" >$newfile
	$EDITOR $newfile
}

_edit_task() {
	local task_id="$1"
	local task_file=$taskdir/$task_id.md
	if test -r "$task_file"; then
		$EDITOR "$task_file"
		return 0
	fi
	logd "task with id $task_id not found"
	return 1
}

edit_task() {
	local task_id="$1"
	if ! hash fzf 2>/dev/null; then
		_edit_task "$task_id"
		return $?
	fi

	local task_file=$taskdir/$task_id.md
	if test -r "$task_file"; then
		$EDITOR "$task_file"
		return
	fi
	local task_query="$task_id"
	local choice=$(list_tasks "$task_query" | fzf)
	if test -z "$choice"; then
		return 0
	fi
	local chosen_task_id=$(echo -n "$choice" | awk '{print $1}' | sed 's/://')
	_edit_task "$chosen_task_id"
}

remove_task() {
	local task_id="$1"
	task_file="$taskdir/$task_id.md"
	if test ! -f $task_file; then
		echo "task $task_id does not exists"
		return
	fi
	title=$(get_task_field $task_id 'title')
	echo -n "remove task $task_id [$title] (y/n)? "
	read c
	if test "$c" = "y" || test "$c" = "Y"; then
		rm -f $task_file
		echo "task $task_id removed"
	else
		echo "aborted"
	fi
}

move_task() {
	local from="$1"
	local to="$2"

	test $from -eq $to && return

	logd "moving [$from] -> [$to]"

	local id_list=$(get_task_id_list)
	cd $taskdir

	if test ! -r $from.md; then
		errmsg "no task with id $from"
		return 1
	fi

	if ! is_there_a_task_with_id "$to"; then
		mv $from.md $to.md
		return 0
	fi

	for id_ in $id_list; do
		logd "checking [$id_]"
		if test $id_ -eq $to; then
			logd "moving [$from] to [$to]"
			mv "$to.md" "temp.md"
			mv $from.md $to.md
			mv "temp.md" "$from.md"
			break
		fi
	done
	cd - >/dev/null 2>&1
}

clean_tasks() {
	echo -n "delete all tasks (y/n)? "
	read c
	if test "$c" = "y" || test "$c" = "Y"; then
		rm -f $taskdir/*.md
		echo "tasks removed"
	else
		echo "aborted"
	fi
}

show_task() {
	local task_id="$1"
	local task_filepath="$taskdir/$task_id.md"

	if test ! -r "$task_filepath"; then
		errmsg "no task found with id [$task_id]"
		exit 1
	fi

	if hash glow >/dev/null 2>&1; then
		glow "$task_filepath"
	else
		cat "$task_filepath"
	fi
}

test -d $taskdir || mkdir -p $taskdir

if [ "$cmd" = "ls" ]; then
	query="$1"
	tags_exclude_regex="$2"
	list_tasks "$query" "$tags_exclude_regex"

elif [ "$cmd" = "l" ]; then
	query="$1"
	list_tasks "$query" "done"

elif [ "$cmd" = "show" ] || [ "$cmd" = "s" ]; then
	show_task $1

elif [ "$cmd" = "add" ] || [ "$cmd" = "a" ]; then
	add_task

elif [ "$cmd" = "edit" ] || [ "$cmd" = "e" ]; then
	if test -z "$TSK_FZF"; then
		edit_task $1
	else
		edit_task_fzf $1
	fi

elif [ "$cmd" = "rm" ] || [ "$cmd" = "r" ]; then
	remove_task $1

elif [ "$cmd" = "mv" ] || [ "$cmd" = "m" ]; then
	from="$1"
	to="$2"
	if test -z "$from" || test -z "$to"; then
		helpmsg
		exit 1
	fi
	move_task $from $to

elif [ "$cmd" = "compact" ] || [ "$cmd" = "gc" ]; then
	compact_ids

elif [ "$cmd" = "git" ] || [ "$cmd" = "g" ]; then
	cd $taskdir
	git $@

elif [ "$cmd" = "sync" ] || [ "$cmd" = "y" ]; then
	cd $taskdir
	git status | grep 'nothing to commit' >/dev/null 2>&1
	test $? = 1 && git add -A && git commit -am 'tsk autosync'
	git pull && git push

elif [ "$cmd" = "clean" ]; then
	clean_tasks

elif [ "$cmd" = "test" ]; then
	export task_template
	$@

else
	helpmsg
fi
