#! /bin/sh
version="0.1.0"
tskdir="${TSK_DIR:-$HOME/.tsk}"
editor="${EDITOR:-vi}"
tmpdir="$TMPDIR:-/tmp"
tskfile_ext="tsk.md"
TSK_DONE_TAG=${TSK_DONE_TAG:-done}

usage() {
    s="$(basename $0)"
    printf "Usage [v$version]:
    $s l [filters]
        shows the task list, eventually filtered
        you can pipe in the result of another $s l to narrow the search
    $s ll [filters]
        shows the task list, eventually filtered searching in tasks body
        you can pipe in the result of another $s l to narrow the search

    $s a <title and tags>
        adds a new task, you can pipe in the task body, e.g.:
        echo 'develop some web application' | $s a Do something #dev #due:tomorrow

    $s d [filters]
        deletes tasks
        you can pipe in a list of task filtered from $s l: this way there is NO CONFIRMATION!

    $s e [filters]
        opens a task in the \$EDITOR
        if no filter is passed, then opens the last created task
        you can pipe in one task filtered from $s l

    $s s [filters]
        shows the tasks to stdout
        you can pipe in a list of task filtered from $s l

    $s g [git cmds/args]
        executes git commands in the tsk directory, e.g.: tsk g pull
    $s y [commit msg]
        executes git add, commit -m 'commit msg' (or 'sync'), pull and push in the tsk directory
    $s h
        shows extended help
"
}
helpmsg() {
    usage; echo
    printf "tsk files:
    a tsk file contains the task title and task tags in the first line, with tags following the title,
    and the task body from the second line on.
    A tsk file is named with the timestamp the task was created and the task id.

tags:
    tasks can be tagged. A 'tag' is a string in the form of #value or #key:value
    where key and value can contain only letters, numbers, undescores '_' and dashes '-', without blank spaces.
    those tags will help searching, task categorization, reports or can be used by external integrations.
    among them there are special tags that are considered in task reports (you can change them with env vars):
    - #done [env: TSK_TAG_DONE , cur: $TSK_TAG_DONE]

env vars:
    - TSK_DEBUG: set it to whatever value to show debug informations [default: unset, cur: ${TSK_DEBUG:-unset}]
    - TSK_DIR: the directory containing your tasks [default: \$HOME/.tsk, cur: $tskdir]
"
}
_err() { printf "%s: error: %s\n" "$(basename "$0")" "$1" >&2; exit 1; }
_warn() { printf "%s: warn: %s\n" "$(basename "$0")" "$1" >&2; }
_info() { printf "%s: %s\n" "$(basename "$0")" "$1" >&2; }
_dbg() { [ "$TRK_DEBUG" ] && printf "%s: debug: %s\n" "$(basename "$0")" "$1" >&2; return 0; }
# $1 = number of chars to receive, $2 = filter for the chars
_rand_chars() { LC_ALL=C tr -dc "$2" </dev/urandom | dd ibs=1 obs=1 count="$1" 2>/dev/null; }
_mktemp() {
    tmpdir=/dev/shm
    [ -w /dev/shm ] || tmpdir=${TMPDIR:-/tmp}
    tmpfile=$tmpdir/sec.$(_rand_chars 16 'A-Za-z0-9') || _err "couldn't generate random characters"
    mkdir -p "$(dirname "$tmpfile")" || _err "couldn't create temp dir"
    touch "$tmpfile" || _err "couldn't create temp file"
    printf "%s" "$tmpfile"
}
_epoch() { date '+%s'; }
_now() { date '+%Y%m%d%H%M%S'; }
_today() { date '+%Y-%m-%d'; }
_validate_date() { date -d "$(printf "$1")" >/dev/null 2>&1;}
_create_task_filename() { printf '%s-%s.%s' "$(_now)" "$(_rand_chars 16 'A-Za-z0-9')" "$tskfile_ext";}
_no_tasks() { ! ls $tskdir/*."$tskfile_ext" >/dev/null 2>&1;}
_get_abs_tskfile_list() { [ ! -t 0 ] && set -- "$(cat)"; echo "$1" | cut -d: -f1 | xargs -I% echo "$tskdir/%.$tskfile_ext";}
_print_task_list() {
    list="$1"
    { for t in $list; do
        [ -f "$t" ] || continue
        { title="$(head -n1 "$t")"; done_mark=''
        echo "$(basename "${t%.$tskfile_ext}"): $done_mark${done_mark+ }$title"; } & done; wait
    } | sort -n
}
list_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    [ ! -t 0 ] && _print_task_list "$(cat | grep -i "${*:-.}" | _get_abs_tskfile_list)"
    [ -t 0 ] && _print_task_list "$tskdir/*.$tskfile_ext" | grep -i "${*:-.}"
}
search_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    [ ! -t 0 ] && _print_task_list "$(cat | _get_abs_tskfile_list | xargs -I% grep -il "${*:-.}" % | sort -u)"
    [ -t 0 ] && _print_task_list "$(for f in "$tskdir/"*".$tskfile_ext"; do echo "$f"; done | xargs -I% grep -il "${*:-.}" % | sort -u)"
}
_get_title() { tskfile="$1";l1="$(head -n1 "$tskfile")"; ! printf "$l1" | grep '#'>/dev/null && printf "$l1" && return 0; printf "$l1"|cut -d'#' -f1;}
_get_tags() { tskfile="$1";l1="$(head -n1 "$tskfile")"; ! printf "$l1" | grep '#'>/dev/null && printf "" && return 0; printf '#'; printf "$l1"|cut -d'#' -f2-;}
_print_task() {
    title="$(_get_title "$1")"
    tags="$(_get_tags "$1")"
    pcmd=cat; command -v mdcat>/dev/null && pcmd=mdcat
    {
        echo "# $title"
        [ -n "$tags" ] && echo "\`$tags\`"
        cat "$1" | sed '1d'
    } | $pcmd
}
show_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    [ -z "$1" ] && [ -t 0 ] && return 0
    [ ! -t 0 ] && tasklist="$(cat | list_tasks "$*")"
    [ -t 0 ] && tasklist="$(list_tasks "$*")"
    tskfiles="$(echo "$tasklist" | _get_abs_tskfile_list)"
    for t in $tskfiles; do
        echo "[$(basename "${t%.$tskfile_ext}")]"
        _print_task "$t"
        echo "___" >&2
    done
}
tag_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    ( [ -z "$1" ] || [ -t 0 ] ) && return 0
    [ ! -t 0 ] && tasklist="$(cat | list_tasks)"
    tskfiles="$(echo "$tasklist" | _get_abs_tskfile_list)"
}
edit_task() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    if [ -z "$1" ] && [ -t 0 ]; then $EDITOR "$tskdir/$(list_tasks | tail -n1 | cut -d: -f1).$tskfile_ext"; return $?; fi
    [ ! -t 0 ] && tasklist="$(cat | list_tasks "$*")"
    [ -t 0 ] && tasklist="$(list_tasks "$*")"
    ( [ -z "$tasklist" ] || [ "$(echo "$tasklist" | wc -l)" -ne 1 ] ) &&
        _warn "task list is:" && echo "$tasklist" 1>&2 && _err "filter the list to obtain only 1 task"
    tskfile="$(echo "$tasklist" | _get_abs_tskfile_list)"
    $EDITOR "$tskfile"
}
del_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    [ ! -t 0 ] && tasklist="$(cat | list_tasks "$*")"
    [ -t 0 ] && tasklist="$(list_tasks "$*")"
    [ -z "$tasklist" ] && _err "no task found"
    tskfiles="$(echo "$tasklist" | _get_abs_tskfile_list)"
    printf "\n%s\n\n" "$tasklist"
    if [ -t 0 ]; then
        printf "delete tasks (y/n)? "
        read -r c
        [ "$c" = "y" ] || return 1
    fi
    rm -f $tskfiles
    _info "deleted"
}
add_task() {
    [ -z "$1" ] && usage && return 1
    body=''; [ ! -t 0 ] && body="$(cat)"
    title="$*"
    tskfile="$(_create_task_filename)"
    echo "$title" >"$tskdir/$tskfile"
    echo "" >>"$tskdir/$tskfile"
    echo "$body" >>"$tskdir/$tskfile"
    _info "created task: $title [$tskfile]"
}
main() {
    cmd="$1"; shift
    case $cmd in
        l) list_tasks "$@";;
        ll) search_tasks "$@";;
        a) add_task "$@";;
        d) del_tasks "$@";;
        t) tag_tasks "$@";;
        e) edit_task "$@";;
        s) show_tasks "$@";;
        h) helpmsg && exit 0;;
        g) cd "$tskdir" && git "$@";;
        y) cd "$tskdir" && git add -A && git commit -m "${*:-sync}" && git pull && git push;;
        run) "$@";;
        *) if command -v $scriptname-"$cmd">/dev/null; then $scriptname-"$cmd" "$@"; else usage; exit 0; fi;
    esac
}
scriptname=$(basename $0)
[ "$1" ] || { usage; exit 0; } && main "$@"
