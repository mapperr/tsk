#! /bin/sh
version="0.1.0"
tskdir="${TSK_DIR:-$HOME/.tsk}"
editor="${EDITOR:-vi}"
tmpdir="$TMPDIR:-/tmp"
tskfile_ext="tsk.md"
TSK_DONE_TAG=${TSK_DONE_TAG:-done}

usage() {
    s="$(basename $0)"
    printf "Usage [v$version]:
    $s l [filters]
        shows the task list, eventually filtered

    $s a <title and tags>
        adds a new task, you can pipe in the task body, e.g.:
        echo 'develop some web application' | $s a Do something #dev #due:tomorrow

    $s d [filters]
        deletes a task

    $s e [filters]
        opens a task in the \$EDITOR
        if no filter is passed, then opens the last created task
        you can pipe in one task filtered from $s l

    $s c [filters]
        prints the tasks to stdout

    $s g [git cmds/args]
        executes git commands in the tsk directory, e.g.: tsk g pull
    $s h
        shows extended help
"
}
helpmsg() {
    usage; echo
    printf "tsk files:
    a tsk file contains the task title in the first line,
    the task tags, separated by one blank space, in the second line
    and the task body from the third line on.
    A tsk file is named with the timestamp the task was created and the task id.


tags:
    tasks can be tagged. A 'tag' is a string in the form of #tag or #tag:value
    where tag and value can contain only letters, numbers, undescores '_' and dashes '-', without blank spaces.
    those tags will help search and task categorization or can be used by external integrations.

env vars:
    - TSK_DEBUG: set it to whatever value to show debug informations [default: unset, cur: ${TSK_DEBUG:-unset}]
    - TSK_DIR: the directory containing your tasks [default: \$HOME/.tsk, cur: $tskdir]
    - TSK_DONE_TAG: the tasks tagged with the TSK_DONE tag are excluded from lists, unless you explicitly include them [default: #done , cur: $TSK_DONE_TAG]
"
}
_err() { printf "%s: error: %s\n" "$(basename "$0")" "$1" >&2; exit 1; }
_warn() { printf "%s: warn: %s\n" "$(basename "$0")" "$1" >&2; }
_info() { printf "%s: %s\n" "$(basename "$0")" "$1" >&2; }
_dbg() { [ "$TRK_DEBUG" ] && printf "%s: debug: %s\n" "$(basename "$0")" "$1" >&2; return 0; }
# $1 = number of chars to receive, $2 = filter for the chars
_rand_chars() { LC_ALL=C tr -dc "$2" </dev/urandom | dd ibs=1 obs=1 count="$1" 2>/dev/null; }
_mktemp() {
    tmpdir=/dev/shm
    [ -w /dev/shm ] || tmpdir=${TMPDIR:-/tmp}
    tmpfile=$tmpdir/sec.$(_rand_chars 16 'A-Za-z0-9') || _err "couldn't generate random characters"
    mkdir -p "$(dirname "$tmpfile")" || _err "couldn't create temp dir"
    touch "$tmpfile" || _err "couldn't create temp file"
    printf "%s" "$tmpfile"
}
_epoch() { date '+%s'; }
_now() { date '+%Y%m%d%H%M%S'; }
_today() { date '+%Y-%m-%d'; }
_validate_date() { date -d "$(printf "$1")" >/dev/null 2>&1;}
_create_task_filename() { printf '%s-%s.%s' "$(_now)" "$(_rand_chars 16 'A-Za-z0-9')" "$tskfile_ext";}
_no_tasks() { ! ls $tskdir/*."$tskfile_ext" >/dev/null 2>&1;}
_get_abs_tskfile_list() { [ ! -t 0 ] && set -- "$(cat)"; echo "$1" | cut -d: -f1 | xargs -I% echo "$tskdir/%.$tskfile_ext";}
_print_task_list() {
    list="$1"
    { for t in $list; do
        [ -f "$t" ] || continue
        title="$(head -n1 "$t")"
        [ -z "$TSK_UNFRIENDLY" ] && printf "$title" | grep "#$TSK_DONE_TAG\b" >/dev/null && done_mark="âœ“"
        echo "$(basename "${t%.$tskfile_ext}"): $done_mark${done_mark+ }$title" & done; wait
    } | sort -n
}
list_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    [ ! -t 0 ] && _print_task_list "$(cat | grep "${*:-.}" | _get_abs_tskfile_list)"
    [ -t 0 ] && _print_task_list "$tskdir/*.$tskfile_ext" | grep "${*:-.}"
}
edit_task() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    if [ -z "$1" ] && [ -t 0 ]; then $EDITOR "$tskdir/$(list_tasks | tail -n1 | cut -d: -f1).$tskfile_ext"; return $?; fi
    [ ! -t 0 ] && tasklist="$(cat | list_tasks "$*")"
    [ -t 0 ] && tasklist="$(list_tasks "$*")"
    [ "$(echo "$tasklist" | wc -l)" -ne 1 ] && _warn "task list is:" && echo "$tasklist" 1>&2 && _err "filter the list to obtain only 1 task"
    tskfile="$(echo "$tasklist" | _get_abs_tskfile_list)"
    $EDITOR "$tskfile"
}
del_tasks() {
    _no_tasks && _warn "no tasks in [$tskdir]" && return 1
    [ ! -t 0 ] && tasklist="$(cat | list_tasks "$*")"
    [ -t 0 ] && tasklist="$(list_tasks "$*")"
    tskfiles="$(echo "$tasklist" | _get_abs_tskfile_list)"
    printf "\n%s\n\n" "$tasklist"
    if [ -t 0 ]; then
        printf "delete tasks (y/n)? "
        read -r c
        [ "$c" = "y" ] || return 1
    fi
    rm -f $tskfiles
    _info "deleted"
}
add_task() {
    [ -z "$1" ] && usage && return 1
    body=''; [ ! -t 0 ] && body="$(cat)"
    title="$*"
    tskfile="$(_create_task_filename)"
    echo "$title" >"$tskdir/$tskfile"
    echo "" >>"$tskdir/$tskfile"
    echo "$body" >>"$tskdir/$tskfile"
    _info "created task: $title [$tskfile]"
}
main() {
    cmd="$1"; shift
    case $cmd in
        l) list_tasks "$@";;
        a) add_task "$@";;
        d) del_tasks "$@";;
        t) tag_tasks "$@";;
        e) edit_task "$@";;
        s) show_tasks "$@";;
        h) helpmsg && exit 0;;
        g) cd "$tskdir" && git "$@";;
        run) "$@";;
        *) if command -v $scriptname-"$cmd">/dev/null; then $scriptname-"$cmd" "$@"; else usage; exit 0; fi;
    esac
}
scriptname=$(basename $0)
[ "$1" ] || { usage; exit 0; } && main "$@"
